package com.example.deduplication.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.Setter;
import org.bson.Document;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Configuration
@ConfigurationProperties(prefix = "deduplication")
@Getter
@Setter
public class AggregationPipelineConfig {

    private List<Map<String, Object>> pipeline;

    /**
     * Returns the pipeline with dynamic placeholders replaced.
     */
    public List<Document> getResolvedPipeline() {
        List<Document> resolvedPipeline = new ArrayList<>();
        ObjectMapper mapper = new ObjectMapper();

        for (Map<String, Object> stage : pipeline) {
            try {
                String json = mapper.writeValueAsString(stage);
                String replaced = replacePlaceholders(json);
                resolvedPipeline.add(Document.parse(replaced));
            } catch (Exception e) {
                throw new RuntimeException("Failed to parse aggregation pipeline stage", e);
            }
        }

        return resolvedPipeline;
    }

    /**
     * Replace all __X_UNIT_AGO__ placeholders (e.g., __7_DAYS_AGO__, __1_MONTH_AGO__) with ISO date strings.
     */
    private String replacePlaceholders(String input) {
        Pattern pattern = Pattern.compile("__([0-9]+)_(MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS)_AGO__");
        Matcher matcher = pattern.matcher(input);

        Map<String, String> replacements = new HashMap<>();

        while (matcher.find()) {
            String fullMatch = matcher.group(0);
            int amount = Integer.parseInt(matcher.group(1));
            String unit = matcher.group(2);

            ChronoUnit chronoUnit = ChronoUnit.valueOf(unit);
            Instant instant = Instant.now().minus(amount, chronoUnit);
            Date date = Date.from(instant);

            try {
                ObjectMapper mapper = new ObjectMapper();
                String isoDate = mapper.writeValueAsString(date); // produces quoted date string
                replacements.put(fullMatch, isoDate);
            } catch (Exception e) {
                throw new RuntimeException("Failed to serialize date for placeholder " + fullMatch, e);
            }
        }

        String result = input;
        for (Map.Entry<String, String> entry : replacements.entrySet()) {
            result = result.replace("\"" + entry.getKey() + "\"", entry.getValue());
        }

        return result;
    }
}


package com.example.deduplication.config;

import org.bson.Document;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;

class AggregationPipelineConfigTest {

    private AggregationPipelineConfig config;

    @BeforeEach
    void setUp() {
        config = new AggregationPipelineConfig();

        List<Map<String, Object>> rawPipeline = new ArrayList<>();

        Map<String, Object> matchStage = new HashMap<>();
        Map<String, Object> localDate = new HashMap<>();
        localDate.put("$gte", "__7_DAYS_AGO__");

        Map<String, Object> matchCondition = new HashMap<>();
        matchCondition.put("localDate", localDate);
        matchStage.put("$match", matchCondition);

        rawPipeline.add(matchStage);

        config.setPipeline(rawPipeline);
    }

    @Test
    void shouldResolvePipelineWith7DaysAgoPlaceholder() {
        List<Document> resolved = config.getResolvedPipeline();

        assertThat(resolved).hasSize(1);

        Document matchStage = resolved.get(0);
        assertThat(matchStage.containsKey("$match")).isTrue();

        Document match = (Document) matchStage.get("$match");
        Document localDate = (Document) match.get("localDate");

        // Assert it contains $gte and it's a Date
        assertThat(localDate.containsKey("$gte")).isTrue();
        assertThat(localDate.get("$gte")).isInstanceOf(Date.class);

        Date resolvedDate = localDate.getDate("$gte");
        Date now = new Date();
        long diffInMillis = now.getTime() - resolvedDate.getTime();

        // Should be within 10 seconds margin of 7 days
        long expectedMillis = 7L * 24 * 60 * 60 * 1000;
        assertThat(Math.abs(diffInMillis - expectedMillis)).isLessThan(10_000);
    }
}


<profiles>
        <!-- Test Profile -->
        <profile>
            <id>test</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <spring.profiles.active>test</spring.profiles.active>
            </properties>
        </profile>

        <!-- Development Profile -->
        <profile>
            <id>dev</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <properties>
                <spring.profiles.active>dev</spring.profiles.active>
            </properties>
        </profile>

        <!-- Production/General Profile -->
        <profile>
            <id>prod</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <spring.profiles.active>prod</spring.profiles.active>
            </properties>
        </profile>
    </profiles>


# src/test/resources/application.yml
# This file will be loaded automatically by Spring Boot during tests
# It takes precedence over src/main/resources/application.yml
spring:
  application:
    name: multi-env-app-test
  profiles:
    active: test
  main:
    allow-bean-definition-overriding: true # Allow overriding beans in tests

server:
  port: 0  # Random port for tests to avoid conflicts

logging:
  level:
    com.example: DEBUG
    org.springframework: WARN
    org.testcontainers: INFO
    org.mongodb.driver: WARN

# Request configuration for tests
app:
  request:
    connection-timeout: 5000
    read-timeout: 5000
    max-retries: 1
    user-agent: MyApp-Test/1.0

# MongoDB is NOT configured in test profile
# Using embedded MongoDB or Testcontainers instead

# Vault and Kube are NOT configured in test profile

---
# src/test/resources/application-integration.yml
# Specific configuration for integration tests
spring:
  profiles:
    active: integration
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop

# For integration tests that need MongoDB
testcontainers:
  mongodb:
    image: mongo:5.0
    port: 27017

app:
  request:
    connection-timeout: 10000
    read-timeout: 10000
    max-retries: 2
    user-agent: MyApp-Integration/1.0

---
# src/test/resources/application-testcontainers.yml
# Configuration for tests using Testcontainers
spring:
  profiles:
    active: testcontainers

app:
  request:
    connection-timeout: 15000
    read-timeout: 15000
    max-retries: 3
    user-agent: MyApp-Testcontainers/1.0

testcontainers:
  reuse:
    enable: true



@SpringBootTest
@ActiveProfiles("test")
class DetectionDuplicatedObjectServiceTest {

    @MockBean
    private MongoCollection<Document> mongoCollection;

    @Autowired
    private AggregationPipelineConf aggregationPipelineConf;

    @Autowired
    private DetectionDuplicatedObjectService detectionService;

    @BeforeEach
    void setup() {
        Mockito.reset(mongoCollection);
    }

    @Test
    void shouldReturnMockedAggregatedDuplicates() throws Exception {
        // 1. Load JSON from file
        ObjectMapper mapper = new ObjectMapper();
        InputStream is = getClass().getResourceAsStream("/data/duplicated-documents.json");
        List<Document> mockedDocs = mapper.readValue(is, new TypeReference<List<Map<String, Object>>>() {})
                                          .stream()
                                          .map(Document::new)
                                          .toList();

        // 2. Mock aggregate()
        AggregateIterable<Document> mockAggregate = mock(AggregateIterable.class);
        when(mockAggregate.iterator()).thenReturn(mockedDocs.iterator());

        when(mongoCollection.aggregate(anyList())).thenReturn(mockAggregate);

        // 3. Call service method (create one if needed)
        detectionService.runDetection();  // <-- You should implement this method to call `coll.aggregate(...)`

        // 4. Optional: assertions or verification
        verify(mongoCollection, times(1)).aggregate(anyList());
    }
}



AggregateIterable<Document> mockIterable = mock(AggregateIterable.class);
when(mockIterable.iterator()).thenReturn(mockedDocs.iterator());




