package com.example.deduplication.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.Setter;
import org.bson.Document;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Configuration
@ConfigurationProperties(prefix = "deduplication")
@Getter
@Setter
public class AggregationPipelineConfig {

    private List<Map<String, Object>> pipeline;

    /**
     * Returns the pipeline with dynamic placeholders replaced.
     */
    public List<Document> getResolvedPipeline() {
        List<Document> resolvedPipeline = new ArrayList<>();
        ObjectMapper mapper = new ObjectMapper();

        for (Map<String, Object> stage : pipeline) {
            try {
                String json = mapper.writeValueAsString(stage);
                String replaced = replacePlaceholders(json);
                resolvedPipeline.add(Document.parse(replaced));
            } catch (Exception e) {
                throw new RuntimeException("Failed to parse aggregation pipeline stage", e);
            }
        }

        return resolvedPipeline;
    }

    /**
     * Replace all __X_UNIT_AGO__ placeholders (e.g., __7_DAYS_AGO__, __1_MONTH_AGO__) with ISO date strings.
     */
    private String replacePlaceholders(String input) {
        Pattern pattern = Pattern.compile("__([0-9]+)_(MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS)_AGO__");
        Matcher matcher = pattern.matcher(input);

        Map<String, String> replacements = new HashMap<>();

        while (matcher.find()) {
            String fullMatch = matcher.group(0);
            int amount = Integer.parseInt(matcher.group(1));
            String unit = matcher.group(2);

            ChronoUnit chronoUnit = ChronoUnit.valueOf(unit);
            Instant instant = Instant.now().minus(amount, chronoUnit);
            Date date = Date.from(instant);

            try {
                ObjectMapper mapper = new ObjectMapper();
                String isoDate = mapper.writeValueAsString(date); // produces quoted date string
                replacements.put(fullMatch, isoDate);
            } catch (Exception e) {
                throw new RuntimeException("Failed to serialize date for placeholder " + fullMatch, e);
            }
        }

        String result = input;
        for (Map.Entry<String, String> entry : replacements.entrySet()) {
            result = result.replace("\"" + entry.getKey() + "\"", entry.getValue());
        }

        return result;
    }
}


package com.example.deduplication.config;

import org.bson.Document;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;

class AggregationPipelineConfigTest {

    private AggregationPipelineConfig config;

    @BeforeEach
    void setUp() {
        config = new AggregationPipelineConfig();

        List<Map<String, Object>> rawPipeline = new ArrayList<>();

        Map<String, Object> matchStage = new HashMap<>();
        Map<String, Object> localDate = new HashMap<>();
        localDate.put("$gte", "__7_DAYS_AGO__");

        Map<String, Object> matchCondition = new HashMap<>();
        matchCondition.put("localDate", localDate);
        matchStage.put("$match", matchCondition);

        rawPipeline.add(matchStage);

        config.setPipeline(rawPipeline);
    }

    @Test
    void shouldResolvePipelineWith7DaysAgoPlaceholder() {
        List<Document> resolved = config.getResolvedPipeline();

        assertThat(resolved).hasSize(1);

        Document matchStage = resolved.get(0);
        assertThat(matchStage.containsKey("$match")).isTrue();

        Document match = (Document) matchStage.get("$match");
        Document localDate = (Document) match.get("localDate");

        // Assert it contains $gte and it's a Date
        assertThat(localDate.containsKey("$gte")).isTrue();
        assertThat(localDate.get("$gte")).isInstanceOf(Date.class);

        Date resolvedDate = localDate.getDate("$gte");
        Date now = new Date();
        long diffInMillis = now.getTime() - resolvedDate.getTime();

        // Should be within 10 seconds margin of 7 days
        long expectedMillis = 7L * 24 * 60 * 60 * 1000;
        assertThat(Math.abs(diffInMillis - expectedMillis)).isLessThan(10_000);
    }
}

